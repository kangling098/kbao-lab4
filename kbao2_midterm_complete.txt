Question 1 - FP Design Question
Library Management System Design
Based on the instructor's feedback regarding the need for a more practical library
system, I have redesigned my Final Project domain model to focus on real-world
library operations with two primary user roles: Librarians and Borrowers. This
design addresses the core functionality that actual library users would expect,
moving away from the previous author/publisher focus toward operational library
management.
Entity Design and Business Domain
My library management system consists of five interconnected entities that
support the daily operations of a modern library system. Each entity represents a
distinct aspect of library operations while maintaining logical relationships that
mirror real-world library processes.
Core Entities
Book Entity: The Book entity serves as the foundation of the system, representing
individual titles available in the library collection. Each book contains essential 
bibliographic information including title, author, ISBN, publication date, page
count, price, and availability status. The entity tracks whether a book is currently
available for borrowing and maintains a due date when checked out. This design
allows for comprehensive book cataloging while supporting inventory
management functions.
Borrower Entity: The Borrower entity represents library members who have the
privilege to borrow books. This entity captures personal information including
first name, last name, birth date, email address, phone number, and complete
mailing address. The system tracks membership status with an active/inactive flag
and records the membership initiation date. Business methods include
functionality to count active loans and check for overdue books, providing
essential information for both borrowers and library staff.
Librarian Entity: The Librarian entity represents library staff members
responsible for managing library operations and processing book loans. Each
librarian has employment information including employee ID, position title, hire
date, salary, and employment status. The entity maintains relationships with both
the library branch where they work and the book loans they process. Business
methods calculate years of service and track processed loan statistics, supporting
performance monitoring and operational analysis.
Library Entity: The Library entity represents physical library branches within
the system. Each library maintains location information including name, address,
city, state, contact details, operating hours, and capacity limits. This entity serves
as a central hub connecting librarians who work at specific branches and book
loans processed at each location. The design supports multi-branch library
systems with centralized management capabilities.
BookLoan Entity: The BookLoan entity functions as the transaction record
connecting all other entities in the system. Each loan record contains temporal
information including loan date, due date, return date, and fine calculations. The
entity captures borrower contact information at the time of loan creation and
maintains notes for special circumstances. Business logic includes overdue
detection, fine calculation, and return processing functionality that automates key
library operations.
Entity Relationships
The system implements five distinct relationships that support comprehensive
library operations while meeting the requirement for at least three relationships
with one bidirectional connection.
Book to BookLoan Relationship: This one-to-many unidirectional relationship 
enables tracking multiple loan instances for individual books throughout the
library system's history. Each book can have numerous loan records over time,
supporting historical analysis and circulation statistics.
Borrower to BookLoan Relationship: The one-to-many bidirectional relationship
between borrowers and book loans represents the core functionality of library
operations. Borrowers can have multiple active and historical loans, while each
loan record maintains a direct reference to the borrowing patron. Helper methods
in the Borrower entity automatically synchronize both sides of this relationship,
ensuring data consistency when loans are created or modified.
Librarian to BookLoan Relationship: Another one-to-many bidirectional
relationship connects librarians to the book loans they process. This design enables
tracking staff performance, managing workflow distribution, and maintaining
accountability for library transactions. The relationship supports both loan
creation and return processing activities.
Library to Librarian Relationship: The one-to-many unidirectional relationship
supports multi-branch library operations by associating staff members with
specific library locations. This design enables branch-specific management and
reporting while maintaining centralized system administration.
Library to BookLoan Relationship: The final one-to-many unidirectional
relationship tracks transactions by library location, supporting branch-specific
circulation analysis and operational reporting. This relationship enables
comparative analysis between different library branches within the system.
Web Application Functionality and User Roles
The library management system exposes different functionality based on user
roles, creating a comprehensive web application that serves both library patrons
and staff members through role-based access control.
Borrower Role Functionality
Borrowers access the system through a patron-focused interface designed for ease
of use and self-service capabilities. The registration process allows new users to
create library accounts with personal information validation and membership
activation. Once registered, borrowers can search the library catalog using
multiple criteria including title, author, ISBN, and subject classification. The
search interface displays real-time availability status and location information for
multi-branch systems.
The borrowing process enables patrons to check out available books electronically, 
with automatic due date calculation based on library policies. Borrowers can view
their complete borrowing history, monitor current active loans, and identify
approaching due dates through an intuitive dashboard interface. The renewal
functionality allows patrons to extend loan periods when no other patrons have
requested the same title.
Personal account management features enable borrowers to update contact
information, view membership status, and monitor any accumulated fines. The
system provides clear notifications for overdue materials and calculates fine
amounts automatically based on library policies.
Librarian Role Functionality
Librarians access an administrative interface providing comprehensive library
management capabilities. Book management functions include adding new titles
to the collection, updating existing bibliographic information, and managing
inventory status including lost or damaged item processing. Staff members can
generate reports on collection usage and identify popular titles for acquisition
planning.
The loan processing system streamlines daily operations by providing quick
checkout and return functionality with automatic fine calculation for overdue 
materials. Librarians can override standard policies for special circumstances and
add explanatory notes to transaction records. The system supports both in-person
and remote loan processing for maximum operational flexibility.
Borrower management capabilities enable staff to review patron accounts,
manage membership status, and process new member applications. Librarians
can access complete borrowing histories to identify patterns and address potential
issues before they become problematic.
Administrative reporting features provide essential operational metrics including
active loan statistics, overdue item reports, and circulation analysis by time period
and library branch. These reports support management decision-making and help
optimize library operations for improved patron service.
Security Role Design
While the current implementation focuses on business domain entities, the system
architecture supports future integration with Java EE security frameworks. The
design anticipates two primary security roles: BORROWER_ROLE for patron
access and LIBRARIAN_ROLE for staff administrative functions. This rolebased approach ensures appropriate access control while maintaining system
security and operational integrity.
The separation of concerns between business entities and security infrastructure
follows enterprise application best practices, allowing for flexible security
implementation that can adapt to changing organizational requirements. Future
enhancements can integrate with institutional authentication systems while
preserving the core business logic and entity relationships established in this
design.
---
---
Question 2 - Jakarta EE Specification and Platform
The Jakarta EE platform represents the evolution of enterprise Java development,
transitioning from Oracle's Java EE to the Eclipse Foundation's open-source
governance model. This transformation reflects fundamental changes in how
enterprise software specifications are developed, implemented, and adopted
across the global Java community.
Understanding Enterprise in Application Development Context
Enterprise application development encompasses software systems designed to
support large-scale business operations across multiple departments, locations,
and user bases. Unlike consumer applications that serve individual users,
enterprise applications must handle complex business processes, integrate with
existing systems, maintain high availability, and support hundreds or thousands
of concurrent users. These applications typically operate in distributed
environments, requiring sophisticated transaction management, security controls,
and scalability mechanisms.
Enterprise applications distinguish themselves through several key characteristics
including mission-critical functionality that directly impacts business operations,
integration requirements with legacy systems and external services, compliance
with industry regulations and standards, and the need for 24/7 availability with
minimal downtime. The complexity of enterprise environments demands robust
architecture patterns, comprehensive testing strategies, and long-term
maintenance planning that extends far beyond typical consumer software
lifecycles.
Industries commonly associated with enterprise development include financial
services where trading platforms, risk management systems, and customer
relationship management solutions require real-time processing and regulatory
compliance. Healthcare organizations deploy electronic health record systems, 
medical imaging platforms, and patient management solutions that must comply
with HIPAA regulations while supporting critical care decisions. Manufacturing
companies implement supply chain management systems, enterprise resource
planning solutions, and quality control platforms that coordinate global
operations across multiple facilities and time zones.
Government agencies at federal, state, and local levels deploy enterprise systems
for citizen services, tax collection, public safety, and regulatory oversight. These
systems must handle sensitive personal data while complying with various
legislative requirements and security mandates. Telecommunications companies
operate billing systems, network management platforms, and customer service
applications that process millions of transactions daily while maintaining service
level agreements.
Application Servers and Jakarta EE Platform Architecture
Application servers serve as the runtime foundation for Jakarta EE applications,
providing essential services including component lifecycle management,
transaction coordination, security enforcement, and resource pooling. These
servers implement Jakarta EE specifications through integrated collections of
APIs and runtime components that work together to support enterprise
application requirements. The application server abstracts complex distributed 
computing concerns, allowing developers to focus on business logic rather than
infrastructure management.
GlassFish, developed by the Eclipse Foundation, serves as the reference
implementation for Jakarta EE specifications. Originally created by Sun
Microsystems and later maintained by Oracle, GlassFish demonstrates how
Jakarta EE specifications should be implemented and provides a baseline for
other commercial and open-source application servers. The server includes
implementations for all major Jakarta EE APIs including Servlet, JSP, EJB, JPA,
CDI, and JAX-RS specifications.
GlassFish plays a crucial role in the Jakarta EE ecosystem by providing a working
reference for specification compliance testing. When new specifications are
developed or existing ones are updated, GlassFish implements these changes first,
allowing other vendors to understand the practical implications and adjust their
implementations accordingly. The reference implementation also serves as a
platform for testing new features and validating specification compatibility across
different environments.
The modular architecture of modern application servers like GlassFish enables
selective deployment of components based on application requirements. This
approach reduces memory footprint and startup time while providing flexibility 
for cloud-native deployments and microservices architectures. The server can be
configured to include only the modules necessary for specific applications,
supporting lean deployment strategies that align with contemporary DevOps
practices.
Jakarta EE APIs and Specifications Overview
Jakarta EE encompasses a comprehensive collection of specifications that address
different aspects of enterprise application development. The Servlet specification
provides the foundation for web application development, defining how HTTP
requests are processed and responses are generated. JavaServer Pages (JSP) and
Jakarta Standard Tag Library (JSTL) specifications enable dynamic web content
generation through template-based approaches. Jakarta Faces provides a
component-based web framework with event handling and validation capabilities.
Enterprise JavaBeans (EJB) specifications define distributed component models
for building scalable business logic layers. The specification includes session beans
for business services, message-driven beans for asynchronous processing, and
entity beans for persistence management. Jakarta Persistence API (JPA) provides
object-relational mapping capabilities for database integration, while Jakarta
Transaction API (JTA) manages distributed transaction coordination across
multiple resources.
Jakarta RESTful Web Services (JAX-RS) enables building RESTful web services
using annotation-driven development approaches. Jakarta JSON Processing and
Jakarta JSON Binding specifications provide standardized APIs for working with
JSON data formats. Jakarta Contexts and Dependency Injection (CDI) offers
dependency injection and context management capabilities that promote loose
coupling and testability.
Jakarta Security API provides authentication and authorization mechanisms for
protecting enterprise resources. Jakarta Mail enables email functionality, while
Jakarta Messaging supports asynchronous communication through message
queues and topics. Batch processing capabilities are provided through Jakarta
Batch specification for handling large-scale data processing requirements.
Specifications versus Implementations
Specifications in the Jakarta EE context define standard interfaces, behaviors, and
contracts that implementations must follow. They describe what functionality
must be provided without dictating how that functionality should be implemented.
This separation enables multiple competing implementations while ensuring
application portability across different vendors and platforms. Specifications
undergo rigorous review processes involving community feedback, 
implementation testing, and compatibility validation.
Implementations represent concrete realizations of specifications that provide
actual runtime functionality. Multiple implementations can exist for a single
specification, each offering unique features, performance characteristics, and
deployment options while maintaining core specification compliance. This
competitive environment encourages innovation and provides developers with
choices that best fit their specific requirements and constraints.
The specification process ensures that applications written against standard APIs
will function correctly across different implementations, promoting vendor
independence and reducing vendor lock-in risks. Organizations can migrate
between implementations based on changing requirements, performance
considerations, or licensing terms without significant application code
modifications.
Jakarta EE Relationship to Java SE
Jakarta EE builds upon Java Standard Edition (Java SE) as its foundation,
extending the core platform with enterprise-specific capabilities. Java SE provides
fundamental programming constructs including language syntax, collection
frameworks, input/output operations, and networking capabilities. Jakarta EE 
leverages these core features while adding distributed computing, transaction
management, security, and web service capabilities essential for enterprise
applications.
The platform dependency ensures that Jakarta EE applications can utilize all Java
SE features while benefiting from enterprise extensions. This relationship allows
developers to apply standard Java programming knowledge within enterprise
contexts while learning additional APIs and patterns specific to distributed
application development. The consistent programming model across both
platforms reduces learning curves and promotes code reuse strategies.
Java SE serves as the runtime foundation for Jakarta EE applications, providing
virtual machine capabilities, memory management, and security sandboxing.
Jakarta EE adds enterprise services through standardized APIs that integrate
seamlessly with Java SE components, creating a comprehensive development and
deployment platform for large-scale applications.
Java Community Process and Jakarta EE Specification Process
The Java Community Process (JCP) historically managed Java platform
specifications including Java EE standards. The JCP involved community
participation through expert groups, public reviews, and reference 
implementation development. This process ensured broad industry input while
maintaining compatibility and quality standards across Java technologies.
The transition from Java EE to Jakarta EE under the Eclipse Foundation
introduced the Jakarta EE Specification Process (JESP), which builds upon the
Eclipse Foundation's specification development methodology. JESP emphasizes
open collaboration, transparency, and community-driven development while
maintaining the rigorous quality standards established by the JCP. The process
includes public participation, regular milestone reviews, and implementation
feedback cycles that ensure specifications meet practical industry requirements.
The Eclipse Foundation's approach to specification development promotes faster
innovation cycles and more responsive updates to changing technology landscapes.
Community members can propose new specifications, contribute to existing ones,
and participate in decision-making processes through established governance
mechanisms. This open approach encourages broader participation and reduces
barriers to entry for new contributors while maintaining technical excellence and
compatibility standards.
The evolution from JCP to JESP represents a fundamental shift toward more open,
community-driven specification development that aligns with modern opensource practices while preserving the enterprise-grade quality and compatibility 
that Java developers expect. This transition ensures that Jakarta EE continues to
evolve in response to industry needs while maintaining the stability and reliability
required for enterprise production environments.